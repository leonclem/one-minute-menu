/**
 * PDF Export Module
 * 
 * Exports menu layouts as PDF documents using Puppeteer for HTML rendering.
 * Supports A4 portrait and landscape orientations with proper pagination.
 * 
 * Features:
 * - Full HTML/CSS rendering with images
 * - A4 page dimensions with configurable orientation
 * - Proper margins and baseline grid
 * - Page break handling to prevent orphaned section headers
 * - Design token consistency for spacing and typography
 */

import { getSharedBrowser, acquirePage } from './puppeteer-shared'
import { PDFDocument, rgb } from 'pdf-lib'
import type { PDFPage } from 'pdf-lib'
import type { LayoutMenuData, LayoutPreset } from '../types'
import { FONT_SIZE_PX, SPACING_PX } from '../design-tokens'
import { formatCurrency } from '../../currency-formatter'

// Use shared Puppeteer browser to avoid userDataDir conflicts across tests

// ============================================================================
// Export Options
// ============================================================================

export interface PDFExportOptions {
  /** Page orientation */
  orientation?: 'portrait' | 'landscape'
  /** Custom page title */
  title?: string
  /** Include page numbers */
  includePageNumbers?: boolean
  /** Custom margins (overrides defaults) */
  margins?: {
    top?: number
    right?: number
    bottom?: number
    left?: number
  }
}

export interface PDFExportResult {
  /** PDF document as Uint8Array */
  pdfBytes: Uint8Array
  /** Size in bytes */
  size: number
  /** Number of pages generated */
  pageCount: number
  /** Generation timestamp */
  timestamp: Date
  /** Generation duration in milliseconds */
  duration: number
}

// ============================================================================
// Main Export Function
// ============================================================================

/**
 * Export menu layout as PDF document using Puppeteer
 * 
 * @param htmlContent - Pre-rendered HTML string
 * @param data - Normalized menu data (for metadata)
 * @param options - PDF export configuration
 * @returns PDF export result with document bytes
 */
export async function exportToPDF(
  htmlContent: string,
  data: LayoutMenuData,
  options: PDFExportOptions = {}
): Promise<PDFExportResult> {
  const startTime = Date.now()

  const {
    orientation = 'portrait',
    title = data.metadata.title,
    includePageNumbers = true,
    margins
  } = options

  let page
  try {
    // Use shared browser instance and acquire a page with concurrency limiting
    page = await acquirePage()

    // Set viewport for consistent rendering
    await page.setViewport({
      width: orientation === 'portrait' ? 794 : 1123, // A4 dimensions in pixels at 96 DPI
      height: orientation === 'portrait' ? 1123 : 794
    })

    // Increase default timeouts when supported; some test mocks may not implement these
    if (typeof (page as any).setDefaultTimeout === 'function') {
      (page as any).setDefaultTimeout(60000)
    }
    if (typeof (page as any).setDefaultNavigationTimeout === 'function') {
      (page as any).setDefaultNavigationTimeout(60000)
    }

    // Set HTML content and wait for network to be idle to ensure fonts and styles load
    // Note: 'networkidle0' removed as we now inline images as base64, and waiting for network can cause timeouts
    await page.setContent(htmlContent, {
      waitUntil: ['domcontentloaded'],
      timeout: 60000
    })
    
    // Give additional time for fonts to load and render
    await page.evaluateHandle('document.fonts.ready')

    // Generate PDF
    const pdfBytes = await page.pdf({
      format: 'A4',
      landscape: orientation === 'landscape',
      printBackground: true,
      margin: margins || {
        top: '20mm',
        right: '15mm',
        bottom: '20mm',
        left: '15mm'
      },
      displayHeaderFooter: includePageNumbers,
      headerTemplate: '<div></div>',
      footerTemplate: includePageNumbers
        ? '<div style="font-size: 10px; text-align: center; width: 100%;"><span class="pageNumber"></span> / <span class="totalPages"></span></div>'
        : '<div></div>'
    })

    await page.close()

    const endTime = Date.now()
    const duration = Math.max(1, endTime - startTime)

    // Compute real page count from generated bytes
    let pageCount = 1
    try {
      const pdfDoc = await PDFDocument.load(pdfBytes)
      pageCount = pdfDoc.getPageCount()
    } catch {
      // Fallback to 1 if parsing fails
      pageCount = 1
    }

    console.log(`[PDFExporter] Generated PDF in ${duration}ms (${pdfBytes.length} bytes)`)

    return {
      pdfBytes,
      size: pdfBytes.length,
      pageCount,
      timestamp: new Date(),
      duration
    }
  } catch (error) {
    if (page) {
      await page.close().catch(() => {})
    }
    throw error
  }
}

// ============================================================================
// Rendering Functions
// ============================================================================

/**
 * Render document title
 */
function renderTitle(
  page: PDFPage,
  title: string,
  x: number,
  y: number,
  maxWidth: number,
  font: any
): number {
  const fontSize = FONT_SIZE_PX['3xl']
  const textWidth = font.widthOfTextAtSize(title, fontSize)

  // Center title if it fits, otherwise left-align
  const textX = textWidth <= maxWidth ? x + (maxWidth - textWidth) / 2 : x

  page.drawText(title, {
    x: textX,
    y: y - fontSize,
    size: fontSize,
    font,
    color: rgb(0, 0, 0)
  })

  return y - fontSize - SPACING_PX.sm
}

/**
 * Render section header
 */
function renderSectionHeader(
  page: PDFPage,
  sectionName: string,
  x: number,
  y: number,
  maxWidth: number,
  font: any
): number {
  const fontSize = FONT_SIZE_PX['2xl']

  page.drawText(sectionName, {
    x,
    y: y - fontSize,
    size: fontSize,
    font,
    color: rgb(0, 0, 0)
  })

  return y - fontSize - SPACING_PX.xs
}

/**
 * Render menu item
 */
function renderMenuItem(
  page: PDFPage,
  item: any,
  currency: string,
  x: number,
  y: number,
  maxWidth: number,
  regularFont: any,
  boldFont: any,
  preset: LayoutPreset
): number {
  const nameSize = FONT_SIZE_PX.base
  const priceSize = FONT_SIZE_PX.base
  const descSize = FONT_SIZE_PX.sm

  let currentY = y

  // Render item name and price on same line
  // Use Currency_Formatter for consistent formatting across all exports
  const currencyCode = currency || 'USD'
  const priceText = formatCurrency(item.price, currencyCode)
  const priceWidth = boldFont.widthOfTextAtSize(priceText, priceSize)

  // Item name (truncate if too long)
  const maxNameWidth = maxWidth - priceWidth - SPACING_PX.md
  let itemName = item.name
  let nameWidth = boldFont.widthOfTextAtSize(itemName, nameSize)

  if (nameWidth > maxNameWidth) {
    // Truncate name with ellipsis
    while (nameWidth > maxNameWidth - boldFont.widthOfTextAtSize('...', nameSize) && itemName.length > 0) {
      itemName = itemName.slice(0, -1)
      nameWidth = boldFont.widthOfTextAtSize(itemName, nameSize)
    }
    itemName += '...'
  }

  page.drawText(itemName, {
    x,
    y: currentY - nameSize,
    size: nameSize,
    font: boldFont,
    color: rgb(0, 0, 0)
  })

  page.drawText(priceText, {
    x: x + maxWidth - priceWidth,
    y: currentY - priceSize,
    size: priceSize,
    font: boldFont,
    color: rgb(0, 0, 0)
  })

  currentY -= nameSize + SPACING_PX.xs

  // Render description if present
  if (item.description) {
    const wrappedDesc = wrapText(item.description, maxWidth, regularFont, descSize)
    for (const line of wrappedDesc) {
      page.drawText(line, {
        x,
        y: currentY - descSize,
        size: descSize,
        font: regularFont,
        color: rgb(0.3, 0.3, 0.3)
      })
      currentY -= descSize + 2
    }
  }

  return currentY
}

/**
 * Calculate height needed for a menu item
 */
function calculateItemHeight(
  item: any,
  preset: LayoutPreset,
  maxWidth: number
): number {
  const nameSize = FONT_SIZE_PX.base
  const descSize = FONT_SIZE_PX.sm

  let height = nameSize + SPACING_PX.xs + SPACING_PX.sm

  if (item.description) {
    // Estimate wrapped lines (rough calculation)
    const avgCharWidth = descSize * 0.5
    const charsPerLine = Math.floor(maxWidth / avgCharWidth)
    const lines = Math.ceil(item.description.length / charsPerLine)
    height += lines * (descSize + 2)
  }

  return height
}

/**
 * Wrap text to fit within max width
 */
function wrapText(text: string, maxWidth: number, font: any, fontSize: number): string[] {
  const words = text.split(' ')
  const lines: string[] = []
  let currentLine = ''

  for (const word of words) {
    const testLine = currentLine ? `${currentLine} ${word}` : word
    const testWidth = font.widthOfTextAtSize(testLine, fontSize)

    if (testWidth <= maxWidth) {
      currentLine = testLine
    } else {
      if (currentLine) {
        lines.push(currentLine)
      }
      currentLine = word
    }
  }

  if (currentLine) {
    lines.push(currentLine)
  }

  return lines
}

/**
 * Add page numbers to all pages
 */
function addPageNumbers(
  pdfDoc: PDFDocument,
  font: any,
  margins: any,
  dimensions: any
): void {
  const pages = pdfDoc.getPages()
  const totalPages = pages.length

  pages.forEach((page, index) => {
    const pageNumber = index + 1
    const text = `${pageNumber} / ${totalPages}`
    const fontSize = FONT_SIZE_PX.xs
    const textWidth = font.widthOfTextAtSize(text, fontSize)

    page.drawText(text, {
      x: (dimensions.width - textWidth) / 2,
      y: margins.bottom / 2,
      size: fontSize,
      font,
      color: rgb(0.5, 0.5, 0.5)
    })
  })
}

// ============================================================================
// Validation and Error Handling
// ============================================================================

/**
 * Validate PDF export options
 */
export function validatePDFExportOptions(options: PDFExportOptions): {
  valid: boolean
  errors: string[]
} {
  const errors: string[] = []

  if (options.orientation && !['portrait', 'landscape'].includes(options.orientation)) {
    errors.push('Invalid orientation. Must be "portrait" or "landscape"')
  }

  if (options.title && options.title.length > 200) {
    errors.push('Title exceeds maximum length (200 characters)')
  }

  if (options.margins) {
    const { top, right, bottom, left } = options.margins
    if (top !== undefined && (top < 0 || top > 500)) {
      errors.push('Invalid top margin. Must be between 0 and 500')
    }
    if (right !== undefined && (right < 0 || right > 500)) {
      errors.push('Invalid right margin. Must be between 0 and 500')
    }
    if (bottom !== undefined && (bottom < 0 || bottom > 500)) {
      errors.push('Invalid bottom margin. Must be between 0 and 500')
    }
    if (left !== undefined && (left < 0 || left > 500)) {
      errors.push('Invalid left margin. Must be between 0 and 500')
    }
  }

  return {
    valid: errors.length === 0,
    errors
  }
}

// ============================================================================
// Export Utilities
// ============================================================================

/**
 * Save PDF to file (Node.js environment only)
 */
export async function savePDFToFile(
  pdfBytes: Uint8Array,
  filepath: string
): Promise<void> {
  if (typeof window !== 'undefined') {
    throw new Error('savePDFToFile can only be used in Node.js environment')
  }

  const fs = await import('fs/promises')
  await fs.writeFile(filepath, pdfBytes)
}

/**
 * Create downloadable PDF blob (browser environment only)
 */
export function createPDFBlob(pdfBytes: Uint8Array): Blob {
  return new Blob([pdfBytes as any], { type: 'application/pdf' })
}

/**
 * Generate data URL for PDF content
 */
export function createPDFDataURL(pdfBytes: Uint8Array): string {
  const base64 = Buffer.from(pdfBytes).toString('base64')
  return `data:application/pdf;base64,${base64}`
}
